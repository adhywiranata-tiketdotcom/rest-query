import{createContext as t,useEffect as e,useState as a,createElement as r,useContext as n,useCallback as o}from"react";function s(){return(s=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var a=arguments[e];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(t[r]=a[r])}return t}).apply(this,arguments)}var c=t({store:null});const i=async function(t){const e=await window.fetch(t);return await e.json()},h=async function(t,e){const a=await window.fetch(t,{method:"POST",body:JSON.stringify(e)});return await a.json()};function d(t){e(t,[])}var l=(...t)=>{console.warn("[TIX REST QUERY WARNING]",...t)},u=(...t)=>{console.error("[TIX REST QUERY ERROR]",...t)};const y=window.localStorage;class p{static save(t,e){const a=p.getStore();a[t]=e,p.setStore(a)}static getStore(){return JSON.parse(y.getItem("tix_rest_query_persisted_cache")||"{}")}static setStore(t){y.setItem("tix_rest_query_persisted_cache",JSON.stringify(t))}static removeStore(){y.removeItem("tix_rest_query_persisted_cache")}}function f({children:t}){const e=p.getStore(),[n,o]=a(e);return r(c.Provider,{value:{store:n,getCachedData:function(t){if(!n[t])return null;try{var e;return JSON.parse(null==(e=n[t])?void 0:e.data)}catch(t){return u("something went wrong when deserializing data ",t),null}},setCacheData:function(t,e,a){const r={data:JSON.stringify(e),cacheStoredAt:null,cacheExpiredAt:null};a.shouldPersist&&p.save(t,r),o(s({},n,{[t]:r}))}}},t)}const w={isLoading:!1,error:null,data:null},m={CACHE_FIRST:"cache-first",NETWORK_ONLY:"network-only",CACHE_ONLY:"cache-only"},E={key:null,cachePolicy:m.CACHE_FIRST,shouldPersist:!1};function O(t,e=E){const r=(t=>{const e=s({},E);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(E,a)?e[a]=t[a]:l((t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(e),h=n(c),u=r.key||btoa(t),y=h.getCachedData(u),p=Boolean(y),f=r.cachePolicy!==m.NETWORK_ONLY,O=[m.CACHE_FIRST,m.NETWORK_ONLY].includes(r.cachePolicy),g=p&&f,S=s({},w,{data:y}),P=g?S:w,[T,F]=a(P),R=o(async()=>{if(p||!O)return;F(s({},T,{isLoading:!0}));const e=await i(t);F(s({},T,{data:e})),f&&h.setCacheData(u,e,r)},[p,O,T,t,f,h,u,r]);return d(()=>{R()}),T}const g={isLoading:!1,error:null,data:null,refetch:()=>{}},S={key:null,httpFetchMethod:"GET",httpFetchBody:null};function P(t,e=S){const r=(t=>{const e=s({},S);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(S,a)?e[a]=t[a]:l((t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(e),[n,c]=a(g),u=o(async()=>{let e;c(s({},n,{isLoading:!0})),"GET"===r.httpFetchMethod&&(e=await i(t)),"POST"===r.httpFetchMethod&&(e=await h(t,r.httpFetchBody)),"PUT"===r.httpFetchMethod&&(e=await async function(t,e){const a=await window.fetch(t,{method:"PUT",body:JSON.stringify(e)});return await a.json()}(t,r.httpFetchBody)),"DELETE"===r.httpFetchMethod&&(e=await async function(t){const e=await window.fetch(t,{method:"DELETE"});return await e.json()}(t)),"PATCH"===r.httpFetchMethod&&(e=await async function(t,e){const a=await window.fetch(t,{method:"PATCH",body:JSON.stringify(e)});return await a.json()}(t,r.httpFetchBody)),c(s({},n,{data:e}))},[n,r.httpFetchBody,r.httpFetchMethod,t]);return d(()=>{u()}),s({},n,{refetch:u})}const T=()=>{},F={isStreaming:!1,isStreamingDone:!1,error:null,data:null},R={streamEndFlag:"isStreamEnded",reqBodyParamsKey:"requestKeys",initialRequestBodyParams:null,responseReqBodyExtractorKey:"requestKeys",stopStreamOnError:!1,stackDataMapper:t=>t,stackDataReducer:()=>({}),onStreamEnd:T,onNextTick:T,onStreamError:T,streamDataFlow:"stack"};function _(t,e=R){const r=(t=>{const e=s({},R);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(R,a)?e[a]=t[a]:l((t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(e),[n,c]=a(F),i=o(async(e={},a=[])=>{try{const o=await h(t,e);if(r.onNextTick(),!1===o[r.streamEndFlag])return void i({[r.reqBodyParamsKey]:o[r.responseReqBodyExtractorKey]},[...a,s({},o)]);if(!0===o[r.streamEndFlag]){if(r.onStreamEnd(),"stack"===r.streamDataFlow)return void c(s({},n,{data:[...a,s({},o)].map(r.stackDataMapper)}));if("object"===r.streamDataFlow)return void c(s({},n,{data:[...a,s({},o)].map(r.stackDataMapper).reduce(r.stackDataReducer)}))}return void l("Stream ended due to stream ending flag is not found or not a proper boolean value")}catch(t){u("something went wrong ",t)}},[t,r,n]);return d(()=>{i({[r.reqBodyParamsKey]:r.initialRequestBodyParams})}),n}export{f as RestQueryProvider,O as useCacheable,P as useFetchable,_ as useStreamable};
//# sourceMappingURL=index.modern.js.map
