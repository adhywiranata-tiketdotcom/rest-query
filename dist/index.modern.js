import{createContext as t,useEffect as e,useState as a,createElement as n,useContext as o,useCallback as r}from"react";function c(){return(c=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var a=arguments[e];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(t[n]=a[n])}return t}).apply(this,arguments)}var s=t({store:null});const i=async function(t){const e=await window.fetch(t);return await e.json()},h=async function(t,e){const a=await window.fetch(t,{method:"POST",body:JSON.stringify(e)});return await a.json()};function d(t){e(t,[])}var l=(...t)=>{console.warn("[TIX REST QUERY WARNING]",...t)},u=(...t)=>{console.error("[TIX REST QUERY ERROR]",...t)};function y({children:t}){const[e,o]=a({});return n(s.Provider,{value:{store:e,getCachedData:function(t){if(!e[t])return null;try{var a;return JSON.parse(null==(a=e[t])?void 0:a.data)}catch(t){return u("something went wrong when deserializing data ",t),null}},setCacheData:function(t,a){const n=JSON.stringify(a);o(c({},e,{[t]:{data:n,cacheStoredAt:null,cacheExpiredAt:null}}))}}},t)}const p={isLoading:!1,error:null,data:null},f={CACHE_FIRST:"cache-first",NETWORK_ONLY:"network-only",CACHE_ONLY:"cache-only"},w={key:null,cachePolicy:f.CACHE_FIRST};function E(t,e=w){const n=(t=>{const e=c({},w);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(w,a)?e[a]=t[a]:l((t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(e),h=o(s),u=n.key||btoa(t),y=h.getCachedData(u),E=Boolean(y),m=n.cachePolicy!==f.NETWORK_ONLY,O=[f.CACHE_FIRST,f.NETWORK_ONLY].includes(n.cachePolicy),P=E&&m,g=c({},p,{data:y}),T=P?g:p,[F,S]=a(T),R=r(async()=>{if(E||!O)return;S(c({},F,{isLoading:!0}));const e=await i(t);S(c({},F,{data:e})),m&&h.setCacheData(u,e)},[E,O,F,t,m,h,u]);return d(()=>{R()}),F}const m={isLoading:!1,error:null,data:null,refetch:()=>{}},O={key:null,httpFetchMethod:"GET",httpFetchBody:null};function P(t,e=O){const n=(t=>{const e=c({},O);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(O,a)?e[a]=t[a]:l((t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(e),[o,s]=a(m),u=r(async()=>{let e;s(c({},o,{isLoading:!0})),"GET"===n.httpFetchMethod&&(e=await i(t)),"POST"===n.httpFetchMethod&&(e=await h(t,n.httpFetchBody)),"PUT"===n.httpFetchMethod&&(e=await async function(t,e){const a=await window.fetch(t,{method:"PUT",body:JSON.stringify(e)});return await a.json()}(t,n.httpFetchBody)),"DELETE"===n.httpFetchMethod&&(e=await async function(t){const e=await window.fetch(t,{method:"DELETE"});return await e.json()}(t)),"PATCH"===n.httpFetchMethod&&(e=await async function(t,e){const a=await window.fetch(t,{method:"PATCH",body:JSON.stringify(e)});return await a.json()}(t,n.httpFetchBody)),s(c({},o,{data:e}))},[o,n.httpFetchBody,n.httpFetchMethod,t]);return d(()=>{u()}),c({},o,{refetch:u})}const g=()=>{},T={isStreaming:!1,isStreamingDone:!1,error:null,data:null},F={streamEndFlag:"isStreamEnded",reqBodyParamsKey:"requestKeys",initialRequestBodyParams:null,responseReqBodyExtractorKey:"requestKeys",stopStreamOnError:!1,stackDataMapper:t=>t,stackDataReducer:()=>({}),onStreamEnd:g,onNextTick:g,onStreamError:g,streamDataFlow:"stack"};function S(t,e=F){const n=(t=>{const e=c({},F);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(F,a)?e[a]=t[a]:l((t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(e),[o,s]=a(T),i=r(async(e={},a=[])=>{try{const r=await h(t,e);if(n.onNextTick(),!1===r[n.streamEndFlag])return void i({[n.reqBodyParamsKey]:r[n.responseReqBodyExtractorKey]},[...a,c({},r)]);if(!0===r[n.streamEndFlag]){if(n.onStreamEnd(),"stack"===n.streamDataFlow)return void s(c({},o,{data:[...a,c({},r)].map(n.stackDataMapper)}));if("object"===n.streamDataFlow)return void s(c({},o,{data:[...a,c({},r)].map(n.stackDataMapper).reduce(n.stackDataReducer)}))}return void l("Stream ended due to stream ending flag is not found or not a proper boolean value")}catch(t){u("something went wrong ",t)}},[t,n,o]);return d(()=>{i({[n.reqBodyParamsKey]:n.initialRequestBodyParams})}),o}export{y as RestQueryProvider,E as useCacheable,P as useFetchable,S as useStreamable};
//# sourceMappingURL=index.modern.js.map
