import{createContext as t,useState as e,createElement as a,useEffect as r,useContext as n,useCallback as o}from"react";function c(){return(c=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var a=arguments[e];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(t[r]=a[r])}return t}).apply(this,arguments)}var s=t({store:null});function i({children:t}){const[r,n]=e({});return a(s.Provider,{value:{store:r,getCachedData:function(t){if(!r[t])return null;try{var e;return JSON.parse(null==(e=r[t])?void 0:e.data)}catch(t){return console.log("[RESTICACHE ERROR]",t),null}},setCacheData:function(t,e){const a=JSON.stringify(e);n(c({},r,{[t]:{data:a,cacheStoredAt:null,cacheExpiredAt:null}}))}}},t)}function l(t){r(t,[])}const u={isLoading:!1,error:null,data:null},d={CACHE_FIRST:"cache-first",NETWORK_ONLY:"network-only",CACHE_ONLY:"cache-only"},y={key:null,cachePolicy:d.CACHE_FIRST};function h(t,a=y){const r=(t=>{const e=c({},y);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(y,a)?e[a]=t[a]:console.warn("[RESTICACHE WARNING]",(t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(a),i=n(s),h=r.key||btoa(t),p=i.getCachedData(h),f=Boolean(p),m=r.cachePolicy!==d.NETWORK_ONLY,E=[d.CACHE_FIRST,d.NETWORK_ONLY].includes(r.cachePolicy),O=f&&m,w=c({},u,{data:p}),R=O?w:u,[g,S]=e(R),C=o(async()=>{if(f||!E)return;S(c({},g,{isLoading:!0}));const e=await async function(t){const e=await window.fetch(t);return await e.json()}(t);S(c({},g,{data:e})),m&&i.setCacheData(h,e)},[f,E,g,t,m,i,h]);return l(()=>{C()}),g}const p=()=>{},f={isStreaming:!1,isStreamingDone:!1,error:null,data:null},m={streamEndFlag:"isStreamEnded",reqBodyParamsKey:"requestKeys",initialRequestBodyParams:null,responseReqBodyExtractorKey:"requestKeys",stopStreamOnError:!1,stackDataMapper:t=>t,stackDataReducer:()=>({}),onStreamEnd:p,onNextTick:p,onStreamError:p,streamDataFlow:"stack"};function E(t,a=m){const r=(t=>{const e=c({},m);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(m,a)?e[a]=t[a]:console.warn("[RESTICACHE WARNING]",(t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(a),[n,s]=e(f),i=o(async(e={},a=[])=>{try{const o=await async function(t,e){const a=await window.fetch(t,{method:"POST",body:JSON.stringify(e)});return await a.json()}(t,e);if(r.onNextTick(),!1===o[r.streamEndFlag])return void i({[r.reqBodyParamsKey]:o[r.responseReqBodyExtractorKey]},[...a,c({},o)]);if(!0===o[r.streamEndFlag]){if(r.onStreamEnd(),"stack"===r.streamDataFlow)return void s(c({},n,{data:[...a,c({},o)].map(r.stackDataMapper)}));if("object"===r.streamDataFlow)return void s(c({},n,{data:[...a,c({},o)].map(r.stackDataMapper).reduce(r.stackDataReducer)}))}return void console.warn("Stream ended due to stream ending flag is not found or not a proper boolean value")}catch(t){console.log("something went wrong ",t)}},[t,r,n]);return l(()=>{i({[r.reqBodyParamsKey]:r.initialRequestBodyParams})}),n}export{i as RestQueryProvider,h as useCacheable,E as useStreamable};
//# sourceMappingURL=index.modern.js.map
