import{createContext as t,useEffect as e,useState as a,createElement as r,useContext as n,useCallback as o}from"react";function s(){return(s=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var a=arguments[e];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(t[r]=a[r])}return t}).apply(this,arguments)}var c=t({store:null});const i=async function(t){const e=await window.fetch(t);return await e.json()},h=async function(t,e){const a=await window.fetch(t,{method:"POST",body:JSON.stringify(e)});return await a.json()};function d(t){e(t,[])}var l=(...t)=>{console.warn("[TIX REST QUERY WARNING]",...t)},u=(...t)=>{console.error("[TIX REST QUERY ERROR]",...t)};class y{static save(t,e){const a=y.getStore();a[t]=e,y.setStore(a)}static getStore(){return JSON.parse(window.localStorage.getItem("tix_restQueryPersistedCache")||"{}")}static setStore(t){window.localStorage.setItem("tix_restQueryPersistedCache",JSON.stringify(t))}}function p({children:t}){const e=y.getStore(),[n,o]=a(e);return r(c.Provider,{value:{store:n,getCachedData:function(t){if(!n[t])return null;try{var e;return JSON.parse(null==(e=n[t])?void 0:e.data)}catch(t){return u("something went wrong when deserializing data ",t),null}},setCacheData:function(t,e,a){const r={data:JSON.stringify(e),cacheStoredAt:null,cacheExpiredAt:null};a.shouldPersist&&y.save(t,r),o(s({},n,{[t]:r}))}}},t)}const w={isLoading:!1,error:null,data:null},f={CACHE_FIRST:"cache-first",NETWORK_ONLY:"network-only",CACHE_ONLY:"cache-only"},m={key:null,cachePolicy:f.CACHE_FIRST,shouldPersist:!1};function E(t,e=m){const r=(t=>{const e=s({},m);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(m,a)?e[a]=t[a]:l((t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(e),h=n(c),u=r.key||btoa(t),y=h.getCachedData(u),p=Boolean(y),E=r.cachePolicy!==f.NETWORK_ONLY,O=[f.CACHE_FIRST,f.NETWORK_ONLY].includes(r.cachePolicy),g=p&&E,S=s({},w,{data:y}),P=g?S:w,[T,F]=a(P),R=o(async()=>{if(p||!O)return;F(s({},T,{isLoading:!0}));const e=await i(t);F(s({},T,{data:e})),E&&h.setCacheData(u,e,r)},[p,O,T,t,E,h,u,r]);return d(()=>{R()}),T}const O={isLoading:!1,error:null,data:null,refetch:()=>{}},g={key:null,httpFetchMethod:"GET",httpFetchBody:null};function S(t,e=g){const r=(t=>{const e=s({},g);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(g,a)?e[a]=t[a]:l((t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(e),[n,c]=a(O),u=o(async()=>{let e;c(s({},n,{isLoading:!0})),"GET"===r.httpFetchMethod&&(e=await i(t)),"POST"===r.httpFetchMethod&&(e=await h(t,r.httpFetchBody)),"PUT"===r.httpFetchMethod&&(e=await async function(t,e){const a=await window.fetch(t,{method:"PUT",body:JSON.stringify(e)});return await a.json()}(t,r.httpFetchBody)),"DELETE"===r.httpFetchMethod&&(e=await async function(t){const e=await window.fetch(t,{method:"DELETE"});return await e.json()}(t)),"PATCH"===r.httpFetchMethod&&(e=await async function(t,e){const a=await window.fetch(t,{method:"PATCH",body:JSON.stringify(e)});return await a.json()}(t,r.httpFetchBody)),c(s({},n,{data:e}))},[n,r.httpFetchBody,r.httpFetchMethod,t]);return d(()=>{u()}),s({},n,{refetch:u})}const P=()=>{},T={isStreaming:!1,isStreamingDone:!1,error:null,data:null},F={streamEndFlag:"isStreamEnded",reqBodyParamsKey:"requestKeys",initialRequestBodyParams:null,responseReqBodyExtractorKey:"requestKeys",stopStreamOnError:!1,stackDataMapper:t=>t,stackDataReducer:()=>({}),onStreamEnd:P,onNextTick:P,onStreamError:P,streamDataFlow:"stack"};function R(t,e=F){const r=(t=>{const e=s({},F);return Object.keys(t).forEach(a=>{Object.prototype.hasOwnProperty.call(F,a)?e[a]=t[a]:l((t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(a))}),e})(e),[n,c]=a(T),i=o(async(e={},a=[])=>{try{const o=await h(t,e);if(r.onNextTick(),!1===o[r.streamEndFlag])return void i({[r.reqBodyParamsKey]:o[r.responseReqBodyExtractorKey]},[...a,s({},o)]);if(!0===o[r.streamEndFlag]){if(r.onStreamEnd(),"stack"===r.streamDataFlow)return void c(s({},n,{data:[...a,s({},o)].map(r.stackDataMapper)}));if("object"===r.streamDataFlow)return void c(s({},n,{data:[...a,s({},o)].map(r.stackDataMapper).reduce(r.stackDataReducer)}))}return void l("Stream ended due to stream ending flag is not found or not a proper boolean value")}catch(t){u("something went wrong ",t)}},[t,r,n]);return d(()=>{i({[r.reqBodyParamsKey]:r.initialRequestBodyParams})}),n}export{p as RestQueryProvider,E as useCacheable,S as useFetchable,R as useStreamable};
//# sourceMappingURL=index.modern.js.map
