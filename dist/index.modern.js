import{useEffect as t,createContext as n,useContext as e,useState as a,useCallback as r,createElement as o}from"react";function c(){return(c=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&(t[a]=e[a])}return t}).apply(this,arguments)}var i=n({store:null});const l={isLoading:!1,error:null,data:null},s={CACHE_FIRST:"cache-first",NETWORK_ONLY:"network-only",CACHE_ONLY:"cache-only"},u={key:null,cachePolicy:s.CACHE_FIRST};function h(n,o=u){const h=(t=>{const n=c({},u);return Object.keys(t).forEach(e=>{Object.prototype.hasOwnProperty.call(u,e)?n[e]=t[e]:console.warn("[RESTICACHE WARNING]",(t=>`Option [${t}] is not part of the API. While this is not an error, ensure the options matches the API.`)(e))}),n})(o),d=e(i),f=h.key||btoa(n),y=d.getCachedData(f),O=Boolean(y),C=h.cachePolicy!==s.NETWORK_ONLY,p=[s.CACHE_FIRST,s.NETWORK_ONLY].includes(h.cachePolicy),E=O&&C,R=c({},l,{data:y}),A=E?R:l,[N,v]=a(A),w=r(async()=>{if(O||!p)return;v(c({},N,{isLoading:!0}));const t=await async function(t){const n=await window.fetch(t);return await n.json()}(n);v(c({},N,{data:t})),C&&d.setCacheData(f,t)},[O,p,N,n,C,d,f]);return t(()=>{w()},[]),N}function d({children:t}){const[n,e]=a({});return o(i.Provider,{value:{store:n,getCachedData:function(t){if(!n[t])return null;try{var e;return JSON.parse(null==(e=n[t])?void 0:e.data)}catch(t){return console.log("[RESTICACHE ERROR]",t),null}},setCacheData:function(t,a){const r=JSON.stringify(a);e(c({},n,{[t]:{data:r,cacheStoredAt:null,cacheExpiredAt:null}}))}}},t)}export{d as ResicacheProvider,h as useCacheable};
//# sourceMappingURL=index.modern.js.map
