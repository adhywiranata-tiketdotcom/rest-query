{"version":3,"file":"index.modern.js","sources":["../src/core/rootContext.ts","../src/utils/fetcher.ts","../src/utils/useEffectOnce.ts","../src/utils/consoleLogger.ts","../src/utils/cachePersistor.ts","../src/core/RestQueryProvider.tsx","../src/core/useCacheable.ts","../src/utils/cacheKeyObfuscator.ts","../src/core/useFetchable.ts","../src/core/useStreamable.ts"],"sourcesContent":["import * as React from 'react';\n\nimport { StoreHashMap } from '../interfaces';\n\ninterface CoreContextAttributes {\n  store: StoreHashMap\n}\n\ninterface CoreContextMethods {\n  getCachedData?(cacheKey: string): string\n  setCacheData?(cacheKey: string, data: any, opts: any): void\n}\n\nexport type CoreContext = CoreContextAttributes & CoreContextMethods\n\nexport default React.createContext<CoreContext>({ store: null });\n","/*\nFetcher Engine which contains tipical RESTful HTTP Method operations.\nOnly supports client-side fetching and might change its implementation\ndepending on the implementation of Abort request and upcoming SSR strategy.\n*/\n\n// Fetcher HTTP object signature\ninterface Fetcher {\n  get: (url: string) => Promise<any>\n  post: (url: string, bodyParams: any) => Promise<any>\n  put: (url: string, bodyParams: any) => Promise<any>\n  performDelete: (url: string) => Promise<any>\n  patch: (url: string, bodyParams: any) => Promise<any>\n}\n\n/**\n * Fetch GET request\n * @param url service url to fetch from\n */\nasync function get(url: string):Promise<any> {\n  const response = await window.fetch(url);\n  const data = await response.json();\n  return data;\n}\n\n/**\n * Fetch POST request\n * @param url service url to fetch from\n * @param bodyParams body to set to POST request\n */\nasync function post(url: string, bodyParams: any):Promise<any> {\n  const response = await window.fetch(url, {\n    method: 'POST',\n    body: JSON.stringify(bodyParams),\n  });\n  const data = await response.json();\n  return data;\n}\n\n/**\n * Fetch PUT request\n * @param url service url to fetch from\n * @param bodyParams body to set to PUT request\n */\nasync function put(url: string, bodyParams: any):Promise<any> {\n  const response = await window.fetch(url, {\n    method: 'PUT',\n    body: JSON.stringify(bodyParams),\n  });\n  const data = await response.json();\n  return data;\n}\n\n/**\n * Fetch DELETE request\n * @param url service url to fetch from\n */\nasync function performDelete(url: string):Promise<any> {\n  const response = await window.fetch(url, {\n    method: 'DELETE',\n  });\n  const data = await response.json();\n  return data;\n}\n\n/**\n * Fetch PATCH request\n * @param url service url to fetch from\n * @param bodyParams body to set to PATCH request\n */\nasync function patch(url: string, bodyParams: any):Promise<any> {\n  const response = await window.fetch(url, {\n    method: 'PATCH',\n    body: JSON.stringify(bodyParams),\n  });\n  const data = await response.json();\n  return data;\n}\n\nconst fetcher: Fetcher = {\n  get,\n  post,\n  put,\n  performDelete,\n  patch,\n};\n\nexport default fetcher;\n","import * as React from 'react';\n\ntype UseEffectHandler = (...args: any[]) => void\n\n/**\n * React useEffect which runs only once per component lifecycle\n * @param fn effect function to run once\n */\nfunction useEffectOnce(fn: UseEffectHandler) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  React.useEffect(fn, []);\n}\n\nexport default useEffectOnce;\n","/* eslint-disable no-console */\n\nconst WARN_LEADING = '[TIX REST QUERY WARNING]';\nconst ERR_LEADING = '[TIX REST QUERY ERROR]';\n\nexport default {\n  warn: (...message: string[]) => {\n    console.warn(WARN_LEADING, ...message);\n  },\n  err: (...message: string[]) => {\n    console.error(ERR_LEADING, ...message);\n  },\n};\n","import { CachedData, StoreHashMap } from '../interfaces';\n\nconst CACHE_PERSISTOR_KEY_PREFIX = 'tix_rest_query_persisted_cache';\nconst INITIAL_CACHE_VAL = '{}';\nconst storageEngine = window.localStorage;\n\n/**\n * CachePersistor works as a single source of truth - engine on cache persistence\n * This pattern avoids any direct access to any other means of browser storage,\n * hence, close for modification outside this particular class.\n */\nabstract class CachePersistor {\n  /**\n   * Mutate the store based on changes on a single key\n   */\n  static save(cacheKey: string, serializedData: CachedData) {\n    const store = CachePersistor.getStore();\n    store[cacheKey] = serializedData;\n    CachePersistor.setStore(store);\n  }\n\n  /**\n   * Get the value of store from the storage engine\n   */\n  static getStore(): StoreHashMap {\n    return JSON.parse(storageEngine.getItem(CACHE_PERSISTOR_KEY_PREFIX) || INITIAL_CACHE_VAL);\n  }\n\n  /**\n   * Overwrite the value of store inside the storage engine\n   */\n  static setStore(persistedCacheStore: StoreHashMap) {\n    storageEngine.setItem(CACHE_PERSISTOR_KEY_PREFIX, JSON.stringify(persistedCacheStore));\n  }\n\n  /**\n   * Purge the cached data from the storage engine. This won't directly affect the context's store.\n   */\n  static removeStore() {\n    storageEngine.removeItem(CACHE_PERSISTOR_KEY_PREFIX);\n  }\n}\n\nexport default CachePersistor;\n","import * as React from 'react';\n\nimport libContext from './rootContext';\nimport { CachedData, StoreHashMap } from '../interfaces';\nimport { consoleLogger, CachePersistor } from '../utils';\n\ninterface RestQueryProps {\n  children: React.ReactElement\n}\n\nfunction RestQueryProvider({ children }: RestQueryProps) {\n  const persistedCacheStore = CachePersistor.getStore();\n  const [cacheStore, setCacheStore] = React.useState<StoreHashMap>(persistedCacheStore);\n\n  /**\n   * Sets provided data to cache depending on the caching storage strategy\n   * @param cacheKey unique key as a reference to the store's hash table\n   * @param data data to cache\n   * @param opts hook options\n   */\n  function setCacheData(cacheKey: string, data: any, opts: any) {\n    // serialize data into JSON string to let the data be stored in browser storage or cookies\n    const serializedData = JSON.stringify(data);\n\n    const cachedData: CachedData = {\n      data: serializedData,\n      // TODO: implement cache expiration logic\n      cacheStoredAt: null,\n      cacheExpiredAt: null,\n    };\n\n    // Persist the serialized data into the cache persistor storage engine\n    if (opts.shouldPersist) {\n      CachePersistor.save(cacheKey, cachedData);\n    }\n\n    setCacheStore({\n      ...cacheStore,\n      [cacheKey]: cachedData,\n    });\n  }\n\n  /**\n   * Returns data stored in the Query Cache\n   * @param cacheKey unique key as a reference to the store's hash table\n   */\n  function getCachedData(cacheKey: string): any {\n    // returns null when requested cache key is not available in the store hash table\n    if (!cacheStore[cacheKey]) {\n      return null;\n    }\n\n    // TODO: implement cache expiration logic before retrieving the data\n\n    try {\n      // deserialized the cached data\n      const deserializedData = JSON.parse(cacheStore[cacheKey]?.data);\n\n      return deserializedData;\n    } catch (e) {\n      // returns null when data failed to be deserialized due to unknown reasons\n      consoleLogger.err('something went wrong when deserializing data ', e);\n\n      return null;\n    }\n  }\n\n  const ctxValue = {\n    store: cacheStore,\n    getCachedData,\n    setCacheData,\n  };\n\n  return (\n    <libContext.Provider value={ctxValue}>\n      {children}\n    </libContext.Provider>\n  );\n}\n\nexport default RestQueryProvider;\n","import * as React from 'react';\n\nimport {\n  useEffectOnce,\n  cacheKeyObfuscator,\n  consoleLogger,\n  fetcher,\n} from '../utils';\nimport rootContext from './rootContext';\n\nconst WARN_INVALID_OPTION_PROPERTY = (property: string) => `Option [${property}] is not part of the API. While this is not an error, ensure the options matches the API.`;\n\ninterface IDataState<T> {\n  isLoading: boolean\n  error?: Error\n  data?: T\n}\nconst initialDataState: IDataState<any> = {\n  isLoading: false,\n  error: null,\n  data: null,\n};\n\ntype CachePolicy = 'cache-first' | 'network-only' | 'cache-only'\n\ninterface ICachePolicies {\n  CACHE_FIRST: CachePolicy\n  NETWORK_ONLY: CachePolicy\n  CACHE_ONLY: CachePolicy\n}\n\nconst CACHE_POLICIES: ICachePolicies = {\n  CACHE_FIRST: 'cache-first',\n  NETWORK_ONLY: 'network-only',\n  CACHE_ONLY: 'cache-only',\n};\n\ntype HookOptionVal = string | boolean | null\n\ninterface IHookOptions {\n  key?: string\n  cachePolicy: CachePolicy\n  shouldPersist?: boolean\n  [optKey: string]: HookOptionVal\n}\n\nconst DEFAULT_OPTS: IHookOptions = {\n  key: null,\n  cachePolicy: CACHE_POLICIES.CACHE_FIRST,\n  shouldPersist: false,\n};\n\ninterface IOptsParam {\n  [optKey: string]: HookOptionVal\n}\n\nconst mergeOptsDefault = (optsParam: IOptsParam) => {\n  const opts = { ...DEFAULT_OPTS };\n\n  Object.keys(optsParam).forEach((property) => {\n    if (Object.prototype.hasOwnProperty.call(DEFAULT_OPTS, property)) {\n      opts[property] = optsParam[property];\n    } else {\n      consoleLogger.warn(WARN_INVALID_OPTION_PROPERTY(property));\n    }\n  });\n\n  return opts;\n};\n\nfunction useCacheable(serviceUrl: string, argOpts = DEFAULT_OPTS) {\n  const options = mergeOptsDefault(argOpts);\n  const ctx = React.useContext(rootContext);\n  const serviceCacheKey = options.key;\n\n  // Determine the cache key based on user-defined key and fallback to encoded service URL\n  // User-defined cache key disregards url into its key, so changing urls will override the data\n  const cacheKey = serviceCacheKey || cacheKeyObfuscator.encode(serviceUrl);\n  const cachedData = ctx.getCachedData(cacheKey);\n\n  // Logic flags based on Cache Policies\n  const isCacheAvailable = Boolean(cachedData);\n  const isCacheAllowed = options.cachePolicy !== CACHE_POLICIES.NETWORK_ONLY;\n  const isNetworkAllowed = [\n    CACHE_POLICIES.CACHE_FIRST,\n    CACHE_POLICIES.NETWORK_ONLY,\n  ].includes(options.cachePolicy);\n  const shouldUseCache = isCacheAvailable && isCacheAllowed;\n\n  // Prepare data for initial hook load\n  const cacheDataForBootstrap = { ...initialDataState, data: cachedData };\n  const bootstrappedData = shouldUseCache ? cacheDataForBootstrap : initialDataState;\n  const [dataState, setDataState] = React.useState(bootstrappedData);\n\n  /**\n   * Perform Fetch Side Effect from Service Url\n   * Will store the data to cache if cache is allowed\n   */\n  const performFetch = React.useCallback(async () => {\n    if (isCacheAvailable || !isNetworkAllowed) {\n      return;\n    }\n\n    // start the fetcher processes\n    setDataState({ ...dataState, isLoading: true });\n    const data = await fetcher.get(serviceUrl);\n    setDataState({ ...dataState, data });\n\n    // set fetched data to cache\n    if (isCacheAllowed) {\n      ctx.setCacheData(cacheKey, data, options);\n    }\n  }, [\n    isCacheAvailable,\n    isNetworkAllowed,\n    dataState,\n    serviceUrl,\n    isCacheAllowed,\n    ctx,\n    cacheKey,\n    options,\n  ]);\n\n  useEffectOnce(() => {\n    performFetch();\n  });\n\n  return dataState;\n}\n\nexport default useCacheable;\n","const obsfuscator = {\n  encode: (str: string) => btoa(str),\n};\n\nexport default obsfuscator;\n","import * as React from 'react';\nimport {\n  useEffectOnce,\n  consoleLogger,\n  fetcher,\n} from '../utils';\n\nconst WARN_INVALID_OPTION_PROPERTY = (property: string) => `Option [${property}] is not part of the API. While this is not an error, ensure the options matches the API.`;\n\ninterface Fetchable<TResponseData> {\n  isLoading: boolean\n  error?: Error\n  data?: TResponseData\n  refetch?: () => void\n}\n\nconst initialDataState: Fetchable<any> = {\n  isLoading: false,\n  error: null,\n  data: null,\n  refetch: () => {},\n};\n\ntype HookOptionVal = string | boolean | null\ntype HttpMethods = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'\n\ninterface IHookOptions {\n  key?: string\n  httpFetchMethod?: HttpMethods\n  httpFetchBody?: any\n  [optKey: string]: HookOptionVal\n}\n\nconst DEFAULT_OPTS: IHookOptions = {\n  key: null,\n  httpFetchMethod: 'GET',\n  httpFetchBody: null,\n};\n\ninterface IOptsParam {\n  [optKey: string]: HookOptionVal\n}\n\nconst mergeOptsDefault = (optsParam: IOptsParam) => {\n  const opts = { ...DEFAULT_OPTS };\n\n  Object.keys(optsParam).forEach((property) => {\n    if (Object.prototype.hasOwnProperty.call(DEFAULT_OPTS, property)) {\n      opts[property] = optsParam[property];\n    } else {\n      consoleLogger.warn(WARN_INVALID_OPTION_PROPERTY(property));\n    }\n  });\n\n  return opts;\n};\n\n/**\n * Hook to Fetch data without any Cache or any other means of data intervention\n * Fetches only once per component mounted, until the refetch method is requested\n * @param serviceUrl URL endpoint to fetch data from\n * @param argOpts Options to modify the behaviour and other configurables\n */\nfunction useFetchable(serviceUrl: string, argOpts = DEFAULT_OPTS) {\n  const options = mergeOptsDefault(argOpts);\n\n  const [dataState, setDataState] = React.useState(initialDataState);\n\n  /**\n   * Perform fetch from service url according to the HTTP methods specified in the options\n   */\n  const performFetch = React.useCallback(async () => {\n    // start the fetcher processes\n    setDataState({ ...dataState, isLoading: true });\n\n    let fetcherResponseData;\n\n    if (options.httpFetchMethod === 'GET') {\n      fetcherResponseData = await fetcher.get(serviceUrl);\n    }\n\n    if (options.httpFetchMethod === 'POST') {\n      fetcherResponseData = await fetcher.post(serviceUrl, options.httpFetchBody);\n    }\n\n    if (options.httpFetchMethod === 'PUT') {\n      fetcherResponseData = await fetcher.put(serviceUrl, options.httpFetchBody);\n    }\n\n    if (options.httpFetchMethod === 'DELETE') {\n      fetcherResponseData = await fetcher.performDelete(serviceUrl);\n    }\n\n    if (options.httpFetchMethod === 'PATCH') {\n      fetcherResponseData = await fetcher.patch(serviceUrl, options.httpFetchBody);\n    }\n\n    // mutate the response data into fetchable data state\n    setDataState({ ...dataState, data: fetcherResponseData });\n  }, [dataState, options.httpFetchBody, options.httpFetchMethod, serviceUrl]);\n\n  useEffectOnce(() => {\n    performFetch();\n\n    // TODO: handle fetch abortion during unmounting to avoid memory leak and wasted API calls\n  });\n\n  return { ...dataState, refetch: performFetch };\n}\n\nexport default useFetchable;\n","import * as React from 'react';\nimport { useEffectOnce, fetcher, consoleLogger } from '../utils';\n\nconst WARN_INVALID_OPTION_PROPERTY = (property: string) => `Option [${property}] is not part of the API. While this is not an error, ensure the options matches the API.`;\n\nconst IDENTITY = (data: any) => data;\nconst EMPTY = () => ({});\nconst NO_OP = () => {};\n\ntype CallbackFunc = (data: any) => any\n\ninterface IStreamableDataState<T> {\n  isStreaming: boolean,\n  isStreamingDone: boolean,\n  error: Error | null,\n  data: T | null,\n}\n\nconst initialDataState: IStreamableDataState<any> = {\n  isStreaming: false,\n  isStreamingDone: false,\n  error: null,\n  data: null,\n};\n\ntype StreamDataFlow = 'stack' | 'object';\ntype HookOptionVal = string | boolean | CallbackFunc | null\n\ninterface IStreamHookOption {\n  streamEndFlag: string,\n  reqBodyParamsKey: string,\n  initialRequestBodyParams: any | null,\n  responseReqBodyExtractorKey: string,\n  stopStreamOnError: boolean,\n  stackDataMapper: any,\n  stackDataReducer: any,\n  onStreamEnd: any,\n  onNextTick: any,\n  onStreamError: any,\n  streamDataFlow: StreamDataFlow\n  [optKey: string]: HookOptionVal\n}\n\nconst DEFAULT_OPTS: IStreamHookOption = {\n  // flag to decide when a stream should be ended. Deep field NOT YET SUPPORTED.\n  streamEndFlag: 'isStreamEnded',\n  // Field that works as a body params for the next request. Deep field NOT YET SUPPORTED.\n  reqBodyParamsKey: 'requestKeys',\n  // Specify the requestBodyParams value that performed during the first time of streaming process\n  initialRequestBodyParams: null,\n  // Field that is going to be passed to the next `reqBodyParamsKey`\n  // from previous streaming response. Deep field NOT YET SUPPORTED.\n  responseReqBodyExtractorKey: 'requestKeys',\n  // if set to true, streaming will stop when api returns error\n  stopStreamOnError: false,\n  stackDataMapper: IDENTITY,\n  stackDataReducer: EMPTY,\n  onStreamEnd: NO_OP,\n  onNextTick: NO_OP,\n  onStreamError: NO_OP,\n  streamDataFlow: 'stack', // stack | object, STACK will place all responses into a single array. OBJECT will replace.\n};\n\ninterface IOptsParam {\n  [optKey: string]: HookOptionVal\n}\n\nconst mergeOptsDefault = (optsParam: IOptsParam) => {\n  const opts = { ...DEFAULT_OPTS };\n\n  Object.keys(optsParam).forEach((property) => {\n    if (Object.prototype.hasOwnProperty.call(DEFAULT_OPTS, property)) {\n      opts[property] = optsParam[property];\n    } else {\n      consoleLogger.warn(WARN_INVALID_OPTION_PROPERTY(property));\n    }\n  });\n\n  return opts;\n};\n\n/**\n * Fetches streaming data and returns the of streaming\n * response, depending on the stream data flow shape\n * Current implementation uses POST request\n * @param {string} serviceUrl\n * @param {*} argOpts\n */\nfunction useStreamable(serviceUrl: string, argOpts = DEFAULT_OPTS) {\n  const options = mergeOptsDefault(argOpts);\n  const [dataState, setDataState] = React.useState(initialDataState);\n\n  // Run PerformFetch function recursively while mutating the streamQueue\n  // streamQueue might be spammed with lots of responses, but after streaming done performed,\n  // the value will automatically be garbage collected.\n  const performFetch = React.useCallback(async (requestBodyParams = {}, streamQueue = []) => {\n    try {\n      const streamDataResponse = await fetcher.post(serviceUrl, requestBodyParams);\n\n      options.onNextTick();\n\n      if (streamDataResponse[options.streamEndFlag] === false) {\n        // perform next fetch with updated stream bodyParamsKey as request body\n        performFetch(\n          { [options.reqBodyParamsKey]: streamDataResponse[options.responseReqBodyExtractorKey] },\n          [...streamQueue, { ...streamDataResponse }],\n        );\n\n        return;\n      }\n\n      if (streamDataResponse[options.streamEndFlag] === true) {\n        options.onStreamEnd();\n\n        if (options.streamDataFlow === 'stack') {\n          setDataState({\n            ...dataState,\n            data: [...streamQueue, { ...streamDataResponse }].map(options.stackDataMapper),\n          });\n\n          return;\n        }\n\n        if (options.streamDataFlow === 'object') {\n          setDataState({\n            ...dataState,\n            data: [...streamQueue, { ...streamDataResponse }]\n              .map(options.stackDataMapper)\n              .reduce(options.stackDataReducer),\n          });\n\n          return;\n        }\n      }\n\n      consoleLogger.warn('Stream ended due to stream ending flag is not found or not a proper boolean value');\n      return;\n    } catch (e) {\n      consoleLogger.err('something went wrong ', e);\n    }\n  }, [serviceUrl, options, dataState]);\n\n  useEffectOnce(() => {\n    performFetch({ [options.reqBodyParamsKey]: options.initialRequestBodyParams });\n  });\n\n  return dataState;\n}\n\nexport default useStreamable;\n"],"names":["React","store","fetcher","async","url","response","window","fetch","json","bodyParams","method","body","JSON","stringify","useEffectOnce","fn","message","console","warn","error","storageEngine","localStorage","CachePersistor","[object Object]","cacheKey","serializedData","getStore","setStore","parse","getItem","persistedCacheStore","setItem","removeItem","RestQueryProvider","children","cacheStore","setCacheStore","libContext","Provider","value","getCachedData","_cacheStore$cacheKey","data","e","consoleLogger","setCacheData","opts","cachedData","cacheStoredAt","cacheExpiredAt","shouldPersist","save","initialDataState","isLoading","CACHE_POLICIES","CACHE_FIRST","NETWORK_ONLY","CACHE_ONLY","DEFAULT_OPTS","key","cachePolicy","useCacheable","serviceUrl","argOpts","options","optsParam","Object","keys","forEach","property","prototype","hasOwnProperty","call","WARN_INVALID_OPTION_PROPERTY","mergeOptsDefault","ctx","rootContext","btoa","isCacheAvailable","Boolean","isCacheAllowed","isNetworkAllowed","includes","shouldUseCache","cacheDataForBootstrap","bootstrappedData","dataState","setDataState","performFetch","refetch","httpFetchMethod","httpFetchBody","useFetchable","fetcherResponseData","NO_OP","isStreaming","isStreamingDone","streamEndFlag","reqBodyParamsKey","initialRequestBodyParams","responseReqBodyExtractorKey","stopStreamOnError","stackDataMapper","stackDataReducer","onStreamEnd","onNextTick","onStreamError","streamDataFlow","useStreamable","requestBodyParams","streamQueue","streamDataResponse","map","reduce"],"mappings":"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"}