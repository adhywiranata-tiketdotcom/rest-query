{"version":3,"file":"index.modern.js","sources":["../src/core/context.ts","../src/core/Provider.tsx","../src/utils/useEffectOnce.ts","../src/core/useCacheable.ts","../src/utils/cacheKeyObfuscator.ts","../src/utils/fetcher.ts","../src/core/useStreamable.ts"],"sourcesContent":["import * as React from 'react';\n\ninterface ICachedData {\n  data?: string\n  cacheStoredAt?: string\n  cacheExpiredAt?: string\n}\n\nexport interface ICoreContextStore {\n  [cacheDataKey: string]: ICachedData\n}\n\ninterface ICoreContextAttrs {\n  store: ICoreContextStore\n}\n\ninterface ICoreContextMethods {\n  getCachedData?(cacheKey: string): string\n  setCacheData?(cacheKey: string, data: any): void\n}\n\ntype CoreContext = ICoreContextAttrs & ICoreContextMethods\n\nexport default React.createContext<CoreContext>({ store: null });\n","import * as React from 'react';\n\nimport libContext, { ICoreContextStore } from './context';\n\nconst ERR_LEADING = '[RESTICACHE ERROR]';\n\ninterface IProps {\n  children: React.ReactElement\n}\nfunction RestQueryProvider({ children }: IProps) {\n  const [cacheStore, setCacheStore] = React.useState<ICoreContextStore>({});\n\n  /**\n   * set data to cache based on provided cache key or encoded url\n   */\n  function setCacheData(cacheKey: string, data: any) {\n    // serialize data into JSON string to let the data be stored in browser storage or cookies\n    const serializedData = JSON.stringify(data);\n\n    // TODO: store serialized data to cookie or local storage\n    setCacheStore({\n      ...cacheStore,\n      [cacheKey]: {\n        data: serializedData,\n        // TODO: implement cache expiration logic\n        cacheStoredAt: null,\n        cacheExpiredAt: null,\n      },\n    });\n  }\n\n  /**\n   * get data based on provided cache key or encoded url\n   */\n  function getCachedData(cacheKey: string) {\n    if (!cacheStore[cacheKey]) {\n      return null;\n    }\n\n    try {\n      const deserializedData = JSON.parse(cacheStore[cacheKey]?.data);\n      return deserializedData;\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log(ERR_LEADING, e);\n      return null;\n    }\n  }\n\n  const ctxValue = {\n    store: cacheStore,\n    getCachedData,\n    setCacheData,\n  };\n\n  return (\n    <libContext.Provider value={ctxValue}>\n      {children}\n    </libContext.Provider>\n  );\n}\n\nexport default RestQueryProvider;\n","import * as React from 'react';\n\ntype UseEffectHandler = (...args: any[]) => void\n\nfunction useEffectOnce(fn: UseEffectHandler) {\n  React.useEffect(fn, []);\n}\n\nexport default useEffectOnce;\n","import * as React from 'react';\nimport { useEffectOnce, cacheKeyObfuscator, fetcher } from '../utils';\n\nimport libContext from './context';\n\nconst WARN_LEADING = '[RESTICACHE WARNING]';\nconst WARN_INVALID_OPTION_PROPERTY = (property: string) => `Option [${property}] is not part of the API. While this is not an error, ensure the options matches the API.`;\n\ninterface IDataState<T> {\n  isLoading: boolean\n  error?: Error\n  data?: T\n}\nconst initialDataState: IDataState<any> = {\n  isLoading: false,\n  error: null,\n  data: null,\n};\n\ntype CachePolicy = 'cache-first' | 'network-only' | 'cache-only'\n\ninterface ICachePolicies {\n  CACHE_FIRST: CachePolicy\n  NETWORK_ONLY: CachePolicy\n  CACHE_ONLY: CachePolicy\n}\n\nconst CACHE_POLICIES: ICachePolicies = {\n  CACHE_FIRST: 'cache-first',\n  NETWORK_ONLY: 'network-only',\n  CACHE_ONLY: 'cache-only',\n};\n\ntype HookOptionVal = string | boolean | null\n\ninterface IHookOptions {\n  key?: string\n  cachePolicy: CachePolicy\n  [optKey: string]: HookOptionVal\n}\n\nconst DEFAULT_OPTS: IHookOptions = {\n  key: null,\n  cachePolicy: CACHE_POLICIES.CACHE_FIRST,\n\n};\n\ninterface IOptsParam {\n  [optKey: string]: HookOptionVal\n}\n\nconst mergeOptsDefault = (optsParam: IOptsParam) => {\n  const opts = { ...DEFAULT_OPTS };\n\n  Object.keys(optsParam).forEach((property) => {\n    if (Object.prototype.hasOwnProperty.call(DEFAULT_OPTS, property)) {\n      opts[property] = optsParam[property];\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(WARN_LEADING, WARN_INVALID_OPTION_PROPERTY(property));\n    }\n  });\n\n  return opts;\n};\n\nfunction useCacheable(serviceUrl: string, argOpts = DEFAULT_OPTS) {\n  const options = mergeOptsDefault(argOpts);\n  const ctx = React.useContext(libContext);\n  const serviceCacheKey = options.key;\n\n  // Determine the cache key based on user-defined key and fallback to encoded service URL\n  // User-defined cache key disregards url into its key, so changing urls will override the data\n  const cacheKey = serviceCacheKey || cacheKeyObfuscator.encode(serviceUrl);\n  const cachedData = ctx.getCachedData(cacheKey);\n\n  // Logic flags based on Cache Policies\n  const isCacheAvailable = Boolean(cachedData);\n  const isCacheAllowed = options.cachePolicy !== CACHE_POLICIES.NETWORK_ONLY;\n  const isNetworkAllowed = [\n    CACHE_POLICIES.CACHE_FIRST,\n    CACHE_POLICIES.NETWORK_ONLY,\n  ].includes(options.cachePolicy);\n  const shouldUseCache = isCacheAvailable && isCacheAllowed;\n\n  // Prepare data for initial hook load\n  const cacheDataForBootstrap = { ...initialDataState, data: cachedData };\n  const bootstrappedData = shouldUseCache ? cacheDataForBootstrap : initialDataState;\n  const [dataState, setDataState] = React.useState(bootstrappedData);\n\n  /**\n   * Perform Fetch Side Effect from Service Url\n   * Will store the data to cache if cache is allowed\n   */\n  const performFetch = React.useCallback(async () => {\n    if (isCacheAvailable || !isNetworkAllowed) {\n      return;\n    }\n\n    // start the fetcher processes\n    setDataState({ ...dataState, isLoading: true });\n    const data = await fetcher.get(serviceUrl);\n    setDataState({ ...dataState, data });\n\n    // set fetched data to cache\n    if (isCacheAllowed) {\n      ctx.setCacheData(cacheKey, data);\n    }\n  }, [isCacheAvailable, isNetworkAllowed, dataState, serviceUrl, isCacheAllowed, ctx, cacheKey]);\n\n  useEffectOnce(() => {\n    performFetch();\n  });\n\n  return dataState;\n}\n\nexport default useCacheable;\n","const obsfuscator = {\n  encode: (str: string) => btoa(str),\n  decode: (str: string) => atob(str),\n};\n\nexport default obsfuscator;\n","/**\n * Fetcher Engine. Can and should be replaced by any other fetcher\n * Should support POST method and HTTP Call Aborting as well!\n * @param  {string} url\n */\nasync function get(url: string) {\n  const response = await window.fetch(url);\n  const data = await response.json();\n  return data;\n}\n\nasync function post(url: string, bodyParams: any) {\n  const response = await window.fetch(url, {\n    method: 'POST',\n    body: JSON.stringify(bodyParams),\n  });\n  const data = await response.json();\n  return data;\n}\n\nconst fetcher = {\n  get,\n  post,\n};\n\nexport default fetcher;\n","import * as React from 'react';\nimport { useEffectOnce, fetcher } from '../utils';\n\nconst WARN_LEADING = '[RESTICACHE WARNING]';\nconst WARN_INVALID_OPTION_PROPERTY = (property: string) => `Option [${property}] is not part of the API. While this is not an error, ensure the options matches the API.`;\n\nconst IDENTITY = (data: any) => data;\nconst EMPTY = () => ({});\nconst NO_OP = () => {};\n\ntype CallbackFunc = (data: any) => any\n\ninterface IStreamableDataState<T> {\n  isStreaming: boolean,\n  isStreamingDone: boolean,\n  error: Error | null,\n  data: T | null,\n}\n\nconst initialDataState: IStreamableDataState<any> = {\n  isStreaming: false,\n  isStreamingDone: false,\n  error: null,\n  data: null,\n};\n\ntype StreamDataFlow = 'stack' | 'object';\ntype HookOptionVal = string | boolean | CallbackFunc | null\n\ninterface IStreamHookOption {\n  streamEndFlag: string,\n  reqBodyParamsKey: string,\n  initialRequestBodyParams: any | null,\n  responseReqBodyExtractorKey: string,\n  stopStreamOnError: boolean,\n  stackDataMapper: any,\n  stackDataReducer: any,\n  onStreamEnd: any,\n  onNextTick: any,\n  onStreamError: any,\n  streamDataFlow: StreamDataFlow\n  [optKey: string]: HookOptionVal\n}\n\nconst DEFAULT_OPTS: IStreamHookOption = {\n  // flag to decide when a stream should be ended. Deep field NOT YET SUPPORTED.\n  streamEndFlag: 'isStreamEnded',\n  // Field that works as a body params for the next request. Deep field NOT YET SUPPORTED.\n  reqBodyParamsKey: 'requestKeys',\n  // Specify the requestBodyParams value that performed during the first time of streaming process\n  initialRequestBodyParams: null,\n  // Field that is going to be passed to the next `reqBodyParamsKey`\n  // from previous streaming response. Deep field NOT YET SUPPORTED.\n  responseReqBodyExtractorKey: 'requestKeys',\n  // if set to true, streaming will stop when api returns error\n  stopStreamOnError: false,\n  stackDataMapper: IDENTITY,\n  stackDataReducer: EMPTY,\n  onStreamEnd: NO_OP,\n  onNextTick: NO_OP,\n  onStreamError: NO_OP,\n  streamDataFlow: 'stack', // stack | object, STACK will place all responses into a single array. OBJECT will replace.\n};\n\ninterface IOptsParam {\n  [optKey: string]: HookOptionVal\n}\n\nconst mergeOptsDefault = (optsParam: IOptsParam) => {\n  const opts = { ...DEFAULT_OPTS };\n\n  Object.keys(optsParam).forEach((property) => {\n    if (Object.prototype.hasOwnProperty.call(DEFAULT_OPTS, property)) {\n      opts[property] = optsParam[property];\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(WARN_LEADING, WARN_INVALID_OPTION_PROPERTY(property));\n    }\n  });\n\n  return opts;\n};\n\n/**\n * Fetches streaming data and returns the of streaming\n * response, depending on the stream data flow shape\n * Current implementation uses POST request\n * @param {string} serviceUrl\n * @param {*} argOpts\n */\nfunction useStreamable(serviceUrl: string, argOpts = DEFAULT_OPTS) {\n  const options = mergeOptsDefault(argOpts);\n  const [dataState, setDataState] = React.useState(initialDataState);\n\n  // Run PerformFetch function recursively while mutating the streamQueue\n  // streamQueue might be spammed with lots of responses, but after streaming done performed,\n  // the value will automatically be garbage collected.\n  const performFetch = React.useCallback(async (requestBodyParams = {}, streamQueue = []) => {\n    try {\n      const streamDataResponse = await fetcher.post(serviceUrl, requestBodyParams);\n\n      options.onNextTick();\n\n      if (streamDataResponse[options.streamEndFlag] === false) {\n        // perform next fetch with updated stream bodyParamsKey as request body\n        performFetch(\n          { [options.reqBodyParamsKey]: streamDataResponse[options.responseReqBodyExtractorKey] },\n          [...streamQueue, { ...streamDataResponse }],\n        );\n\n        return;\n      }\n\n      if (streamDataResponse[options.streamEndFlag] === true) {\n        options.onStreamEnd();\n\n        if (options.streamDataFlow === 'stack') {\n          setDataState({\n            ...dataState,\n            data: [...streamQueue, { ...streamDataResponse }].map(options.stackDataMapper),\n          });\n\n          return;\n        }\n\n        if (options.streamDataFlow === 'object') {\n          setDataState({\n            ...dataState,\n            data: [...streamQueue, { ...streamDataResponse }]\n              .map(options.stackDataMapper)\n              .reduce(options.stackDataReducer),\n          });\n\n          return;\n        }\n      }\n\n      // eslint-disable-next-line no-console\n      console.warn('Stream ended due to stream ending flag is not found or not a proper boolean value');\n      return;\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log('something went wrong ', e);\n    }\n  }, [serviceUrl, options, dataState]);\n\n  useEffectOnce(() => {\n    performFetch({ [options.reqBodyParamsKey]: options.initialRequestBodyParams });\n  });\n\n  return dataState;\n}\n\nexport default useStreamable;\n"],"names":["React","store","RestQueryProvider","children","cacheStore","setCacheStore","libContext","Provider","value","getCachedData","cacheKey","JSON","parse","_cacheStore$cacheKey","data","e","console","log","setCacheData","serializedData","stringify","[object Object]","cacheStoredAt","cacheExpiredAt","useEffectOnce","fn","initialDataState","isLoading","error","CACHE_POLICIES","CACHE_FIRST","NETWORK_ONLY","CACHE_ONLY","DEFAULT_OPTS","key","cachePolicy","useCacheable","serviceUrl","argOpts","options","optsParam","opts","Object","keys","forEach","property","prototype","hasOwnProperty","call","warn","WARN_INVALID_OPTION_PROPERTY","mergeOptsDefault","ctx","btoa","cachedData","isCacheAvailable","Boolean","isCacheAllowed","isNetworkAllowed","includes","shouldUseCache","cacheDataForBootstrap","bootstrappedData","dataState","setDataState","performFetch","async","url","response","window","fetch","json","fetcher","NO_OP","isStreaming","isStreamingDone","streamEndFlag","reqBodyParamsKey","initialRequestBodyParams","responseReqBodyExtractorKey","stopStreamOnError","stackDataMapper","stackDataReducer","onStreamEnd","onNextTick","onStreamError","streamDataFlow","useStreamable","requestBodyParams","streamQueue","streamDataResponse","bodyParams","method","body","map","reduce"],"mappings":"sUAuBA,MAAeA,EAAiC,CAAEC,MAAO,OCdzD,SAASC,GAAkBC,SAAEA,IAC3B,MAAOC,EAAYC,GAAiBL,EAAkC,IA6CtE,OACEA,EAACM,EAAWC,UAASC,MAPN,CACfP,MAAOG,EACPK,cAjBF,SAAuBC,GACrB,IAAKN,EAAWM,GACd,YAGF,UAEE,OADyBC,KAAKC,eAAMR,EAAWM,WAAXG,EAAsBC,MAE1D,MAAOC,GAGP,OADAC,QAAQC,IAxCM,qBAwCWF,UAQ3BG,aArCF,SAAsBR,EAAkBI,GAEtC,MAAMK,EAAiBR,KAAKS,UAAUN,GAGtCT,OACKD,GACHiB,CAACX,GAAW,CACVI,KAAMK,EAENG,cAAe,KACfC,eAAgB,YA+BjBpB,GCrDP,SAASqB,EAAcC,GACrBzB,EAAgByB,EAAI,ICAtB,MAQMC,EAAoC,CACxCC,WAAW,EACXC,MAAO,KACPd,KAAM,MAWFe,EAAiC,CACrCC,YAAa,cACbC,aAAc,eACdC,WAAY,cAWRC,EAA6B,CACjCC,IAAK,KACLC,YAAaN,EAAeC,aAuB9B,SAASM,EAAaC,EAAoBC,EAAUL,GAClD,MAAMM,EAhBkBC,CAAAA,IACxB,MAAMC,OAAYR,GAWlB,OATAS,OAAOC,KAAKH,GAAWI,QAASC,IAC1BH,OAAOI,UAAUC,eAAeC,KAAKf,EAAcY,GACrDJ,EAAKI,GAAYL,EAAUK,GAG3B7B,QAAQiC,KAtDO,uBACiBJ,CAAAA,cAAgCA,6FAqDrCK,CAA6BL,MAIrDJ,GAISU,CAAiBb,GAC3Bc,EAAMpD,EAAiBM,GAKvBI,EAJkB6B,EAAQL,KCpEPmB,KDwEqChB,GACxDiB,EAAaF,EAAI3C,cAAcC,GAG/B6C,EAAmBC,QAAQF,GAC3BG,EAAiBlB,EAAQJ,cAAgBN,EAAeE,aACxD2B,EAAmB,CACvB7B,EAAeC,YACfD,EAAeE,cACf4B,SAASpB,EAAQJ,aACbyB,EAAiBL,GAAoBE,EAGrCI,OAA6BnC,GAAkBZ,KAAMwC,IACrDQ,EAAmBF,EAAiBC,EAAwBnC,GAC3DqC,EAAWC,GAAgBhE,EAAe8D,GAM3CG,EAAejE,EAAkBkE,UACrC,GAAIX,IAAqBG,EACvB,OAIFM,OAAkBD,GAAWpC,WAAW,KACxC,MAAMb,QEhGVoD,eAAmBC,GACjB,MAAMC,QAAiBC,OAAOC,MAAMH,GAEpC,aADmBC,EAASG,OF8FPC,CAAYnC,GAC/B2B,OAAkBD,GAAWjD,KAAAA,KAGzB2C,GACFL,EAAIlC,aAAaR,EAAUI,IAE5B,CAACyC,EAAkBG,EAAkBK,EAAW1B,EAAYoB,EAAgBL,EAAK1C,IAMpF,OAJAc,EAAc,KACZyC,MAGKF,EG/GT,MAKMU,EAAQ,OAWR/C,EAA8C,CAClDgD,aAAa,EACbC,iBAAiB,EACjB/C,MAAO,KACPd,KAAM,MAqBFmB,EAAkC,CAEtC2C,cAAe,gBAEfC,iBAAkB,cAElBC,yBAA0B,KAG1BC,4BAA6B,cAE7BC,mBAAmB,EACnBC,gBAlDgBnE,GAAcA,EAmD9BoE,iBAlDY,SAmDZC,YAAaV,EACbW,WAAYX,EACZY,cAAeZ,EACfa,eAAgB,SA6BlB,SAASC,EAAclD,EAAoBC,EAAUL,GACnD,MAAMM,EAvBkBC,CAAAA,IACxB,MAAMC,OAAYR,GAWlB,OATAS,OAAOC,KAAKH,GAAWI,QAASC,IAC1BH,OAAOI,UAAUC,eAAeC,KAAKf,EAAcY,GACrDJ,EAAKI,GAAYL,EAAUK,GAG3B7B,QAAQiC,KAzEO,uBACiBJ,CAAAA,cAAgCA,6FAwErCK,CAA6BL,MAIrDJ,GAWSU,CAAiBb,IAC1ByB,EAAWC,GAAgBhE,EAAe0B,GAK3CuC,EAAejE,EAAkBkE,MAAOsB,EAAoB,GAAIC,EAAc,MAClF,IACE,MAAMC,QDxFZxB,eAAoBC,EAAawB,GAC/B,MAAMvB,QAAiBC,OAAOC,MAAMH,EAAK,CACvCyB,OAAQ,OACRC,KAAMlF,KAAKS,UAAUuE,KAGvB,aADmBvB,EAASG,OCmFSC,CAAanC,EAAYmD,GAI1D,GAFAjD,EAAQ6C,cAE0C,IAA9CM,EAAmBnD,EAAQqC,eAO7B,YALAX,EACE,CAAE5C,CAACkB,EAAQsC,kBAAmBa,EAAmBnD,EAAQwC,8BACzD,IAAIU,OAAkBC,KAM1B,IAAkD,IAA9CA,EAAmBnD,EAAQqC,eAAyB,CAGtD,GAFArC,EAAQ4C,cAEuB,UAA3B5C,EAAQ+C,eAMV,YALAtB,OACKD,GACHjD,KAAM,IAAI2E,OAAkBC,IAAsBI,IAAIvD,EAAQ0C,oBAMlE,GAA+B,WAA3B1C,EAAQ+C,eAQV,YAPAtB,OACKD,GACHjD,KAAM,IAAI2E,OAAkBC,IACzBI,IAAIvD,EAAQ0C,iBACZc,OAAOxD,EAAQ2C,qBASxB,YADAlE,QAAQiC,KAAK,qFAEb,MAAOlC,GAEPC,QAAQC,IAAI,wBAAyBF,KAEtC,CAACsB,EAAYE,EAASwB,IAMzB,OAJAvC,EAAc,KACZyC,EAAa,CAAE5C,CAACkB,EAAQsC,kBAAmBtC,EAAQuC,6BAG9Cf"}